import express from 'express'
import fs from "fs"
import path from 'path'
import LRU from 'lru-cache'
const favicon = require('serve-favicon')
import {createBundleRenderer} from 'vue-server-renderer'

const app = express()
const resolve = file => path.resolve(__dirname, file)

const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')

const isProd = process.env.NODE_ENV === 'production'

const createRenderer = (bundle, options) => {
	// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
	return createBundleRenderer(bundle, Object.assign(options, {
		template,
		// for component caching
		cache: LRU({
			max: 1000,
			maxAge: 1000 * 60 * 15
		}),
		// this is only needed when vue-server-renderer is npm-linked
		basedir: resolve('./dist'),
		// recommended for performance
		runInNewContext: false
	}))
}

let renderer
let readyPromise
if (isProd) {
// In production: create server renderer using built server bundle.
	// The server bundle is generated by vue-ssr-webpack-plugin.
	const bundle = require('./dist/vue-ssr-server-bundle.json')
	// The client manifests are optional, but it allows the renderer
	// to automatically infer preload/prefetch links and directly add <script>
	// tags for any async chunks used during render, avoiding waterfall requests.
	const clientManifest = require('./dist/vue-ssr-client-manifest.json')
	renderer = createRenderer(bundle, {
		clientManifest
	})
} else {
	readyPromise = require('./build/setup-dev-server')(app, (bundle, options) => {
		renderer = createRenderer(bundle, options)
	})
}

const serve = (path, cache) => express.static(resolve(path), {
	maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
})

app.use('/dist', serve('./dist', true))
app.use('/public', serve('./public', true))
app.use(favicon('./public/logo-48.png'))


const render = (req, res) => {
	const s = Date.now()

	res.setHeader("Content-Type", "text/html")
	// res.setHeader("Server", serverInfo)

	const handleError = err => {
		if (err.url) {
			res.redirect(err.url)
		} else if (err.code === 404) {
			res.status(404).send('404 | Page Not Found')
		} else {
			// Render Error Page or Redirect
			res.status(500).send('500 | Internal Server Error')
			console.error(`error during render : ${req.url}`)
			console.error(err.stack)
		}
	}

	const context = {
		title: 'ssr demo', // default title
		url: req.url
	}
	console.log(req.url)
	renderer.renderToString(context, (err, html) => {
		if (err) {
			return handleError(err)
		}
		res.send(html)
		if (!isProd) {
			console.log(`whole request: ${Date.now() - s}ms`)
		}
	})
}

app.get('*', isProd ? render : (req, res) => {
	readyPromise.then(() => render(req, res))
})

const port = process.env.PORT || 9000
app.listen(port, () => {
	console.log(`server started at localhost:${port}`)
})
